
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { fileURLToPath } from 'url';
import process from 'process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');
const DISPATCHES_DIR = path.resolve(PROJECT_ROOT, 'data/dispatches');
const OUTPUT_FILE = path.resolve(PROJECT_ROOT, 'data/dispatches.ts');
const EXPORT_SCRIPT_FILE = path.resolve(PROJECT_ROOT, 'data/export-for-script.ts');
const CACHE_DIR = path.resolve(PROJECT_ROOT, '.cache');
const CACHE_FILE = path.resolve(CACHE_DIR, 'dispatches.json');

const generate = () => {
  console.log('[Generator] Syncing dispatch data...');

  if (!fs.existsSync(DISPATCHES_DIR)) {
    console.warn(`[Generator] Directory not found: ${DISPATCHES_DIR}`);
    // @ts-ignore
    process.exit(1);
  }

  // 1. Auto-discover all .ts files
  const files = fs.readdirSync(DISPATCHES_DIR)
    .filter(file => 
      file.endsWith('.ts') && 
      !file.startsWith('index') && 
      !file.startsWith('.d.ts') &&
      !file.startsWith('_') // Ignore drafts
    )
    .sort();

  // 2. Incremental Check
  // We hash the file list. If filenames haven't changed, the imports remain valid.
  // The content of dispatches is loaded via import(), so content changes don't require regenerating the index files.
  if (!fs.existsSync(CACHE_DIR)) {
      fs.mkdirSync(CACHE_DIR, { recursive: true });
  }

  const fileListHash = crypto.createHash('sha256').update(JSON.stringify(files)).digest('hex');
  let cache = {};
  try {
      if (fs.existsSync(CACHE_FILE)) {
          cache = JSON.parse(fs.readFileSync(CACHE_FILE, 'utf8'));
      }
  } catch (e) {}

  // Only skip if cache matches AND output files actually exist
  // @ts-ignore
  if (cache.fileListHash === fileListHash && fs.existsSync(OUTPUT_FILE) && fs.existsSync(EXPORT_SCRIPT_FILE)) {
      console.log('[Generator] Dispatch list unchanged. Skipping generation.');
      return;
  }

  const imports = [];
  const listItems = [];
  const switchCases = [];
  
  // For export-for-script.ts
  const scriptImports = [];
  const contentMapEntries = [];

  files.forEach(file => {
    // Remove extension
    const fileName = file.replace(/\.ts$/, '');
    
    // Create valid variable name (e.g. my-post -> my_post)
    let varName = fileName.replace(/[^a-zA-Z0-9_]/g, '_');
    if (/^[0-9]/.test(varName)) {
        varName = '_' + varName;
    }
    
    // Prepare data/dispatches.ts (Lazy Loading)
    imports.push(`import { ${varName}_meta } from './dispatches/${fileName}';`);
    listItems.push(`${varName}_meta`);
    switchCases.push(`      case '${fileName}':`);
    switchCases.push(`        return (await import('./dispatches/${fileName}')).${varName}_content;`);

    // Prepare data/export-for-script.ts (Eager Loading for SEO)
    scriptImports.push(`import { ${varName}_content } from './dispatches/${fileName}';`);
    contentMapEntries.push(`  '${fileName}': ${varName}_content`);
  });

  // 3. Write data/dispatches.ts
  const dispatchesContent = `
// -----------------------------------------------------------------------------
// THIS FILE IS AUTO-GENERATED BY scripts/generate-dispatches.mjs
// DO NOT EDIT MANUALLY.
//
// TO ADD A NEW DISPATCH:
// 1. Create a file in data/dispatches/ (e.g., my-post.ts)
// 2. Export named constants matching the filename:
//    - export const my_post_meta: DispatchSummary = { id: 'my-post', ... }
//    - export const my_post_content: LocalizedContent = { ... }
// -----------------------------------------------------------------------------

import { DispatchSummary, LocalizedContent } from '../types';
${imports.join('\n')}

const list: DispatchSummary[] = [
  ${listItems.join(',\n  ')}
];

// Export lightweight metadata list
export const dispatchesList: DispatchSummary[] = list
  .filter(item => item && item.id && item.slug)
  .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

// Dynamic loader for heavy content
export const loadDispatchContent = async (id: string): Promise<LocalizedContent | null> => {
  try {
    switch (id) {
${switchCases.join('\n')}
      default:
        return null;
    }
  } catch (e) {
    console.error(\`Failed to load content for \${id}\`, e);
    return null;
  }
};
`;

  fs.writeFileSync(OUTPUT_FILE, dispatchesContent.trim() + '\n');
  console.log(`[Generator] Updated data/dispatches.ts (${files.length} items)`);

  // 4. Write data/export-for-script.ts
  // This ensures the SEO build script always has access to the latest content
  const exportScriptContent = `
// -----------------------------------------------------------------------------
// THIS FILE IS AUTO-GENERATED BY scripts/generate-dispatches.mjs
// DO NOT EDIT MANUALLY.
// -----------------------------------------------------------------------------

import { dispatchesList } from './dispatches';
import { Dispatch } from '../types';
${scriptImports.join('\n')}

export { promotionsData } from './promotions';
export { staticRoutes, allRoutes } from './routes';
export { archiveData } from './archive';
// Export the new CONFIG object
export { SITE_URL, CONFIG } from '../config';

const contentMap: Record<string, any> = {
${contentMapEntries.join(',\n')}
};

export const dispatchesData: Dispatch[] = dispatchesList.map(meta => ({
  ...meta,
  content: contentMap[meta.id] || { en: '', id: '' }
}));
`;

  fs.writeFileSync(EXPORT_SCRIPT_FILE, exportScriptContent.trim() + '\n');
  console.log(`[Generator] Updated data/export-for-script.ts (${files.length} items)`);

  // Update Cache
  fs.writeFileSync(CACHE_FILE, JSON.stringify({ fileListHash }));
};

generate();
